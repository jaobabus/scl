#include "scl/parse.h"
#include <scl/consolebuffer.h>

#include <scl/ard.h>
#include <scl/calt.h>
#include <memory.h>


// ------------------- For debug ------------------- //

#define coprintf(...)

// ------------------------------------------------- //

SCL_CPP_ANON_NAMESPACE_START

// -- ARD-Table 'EscapeTable' --
// THIS BLOCK AUTOGENERATED
// Do NOT change it
// {

/*
 * EscapeRule:
 *   [0: bit[3]] [ret: bit] [action: bit[4]]
 *
 */

#define SCLCB_PRIVATE_Return 0x10

typedef enum { 
    NoAction = 0,
    CursorUp = 1,
    CursorDown = 2,
    CursorRight = 3,
    CursorLeft = 4,
    DeleteBefore = 5,
    DeleteAfter = 6,
    Execute = 7,
    Skip = 8,
    Fallback = 9,
    Insert = 10,
} Action;

SCL_STATIC_API_BEFORE_TYPE
const uint8_t escape_rules[] = {
/* 00 */ // Root escapes
  /* 00 */ '\e' | ARD_HIA,
  /* -- */ NoAction | SCLCB_PRIVATE_Return,
  /* -- */ 0x18, // 2lvl escapes
  /* 03 */ '\x7F',
  /* -- */ DeleteBefore | SCLCB_PRIVATE_Return, // Backspace
  /* 05 */ '\n',
  /* -- */ Execute | SCLCB_PRIVATE_Return, // Execute command
  /* 07 */ '\r',
  /* -- */ Execute | SCLCB_PRIVATE_Return, // Execute command
  /* 09 */ 0x00,
  /* -- */ Insert | SCLCB_PRIVATE_Return,
/* 0B */ // lbrace escapes
  /* 0B */ 'A',
  /* -- */ CursorUp | SCLCB_PRIVATE_Return, // Key arrow up
  /* 0D */ 'B',
  /* -- */ CursorDown | SCLCB_PRIVATE_Return, // Key arrow down
  /* 0F */ 'C',
  /* -- */ CursorRight | SCLCB_PRIVATE_Return, // Key arrow right
  /* 11 */ 'D',
  /* -- */ CursorLeft | SCLCB_PRIVATE_Return, // Key arrow left
  /* 13 */ '3' | ARD_HIA,
  /* -- */ DeleteAfter | SCLCB_PRIVATE_Return, // Key delete
  /* -- */ 0x1D, // Skip rules
  /* 16 */ 0x00,
  /* -- */ Fallback | SCLCB_PRIVATE_Return,
/* 18 */ // 2lvl escapes
  /* 18 */ '[' | ARD_HIA,
  /* -- */ NoAction | SCLCB_PRIVATE_Return,
  /* -- */ 0x0B, // lbrace escapes
  /* 1B */ 0x00,
  /* -- */ Fallback | SCLCB_PRIVATE_Return,
/* 1D */ // Skip rules
  /* 1D */ '~',
  /* -- */ Skip | SCLCB_PRIVATE_Return,
  /* 1F */ 0x00,
  /* -- */ Fallback | SCLCB_PRIVATE_Return,
};

// }
// -- ARD-Table --



SCL_STATIC_API_BEFORE_TYPE
uint8_t translate(uint8_t ch)
{
    if (ch == '\e')
        return '^';
    if (ch < 0x20)
        return '?';
    return ch;
}

//static
//void buffer_insert(uint8_t* buffer, size_t buf_size, size_t index, char ch);
SCL_STATIC_API_BEFORE_TYPE
void buffer_insert(uint8_t* buffer, size_t buf_size, size_t index, char ch)
{
    if (index < buf_size)
        for (size_t i = buf_size - 1; i > index; i--)
            buffer[i] = buffer[i - 1];
    buffer[index] = ch;
}

//static
//void buffer_pop(uint8_t* buffer, size_t buf_size, size_t index);
SCL_STATIC_API_BEFORE_TYPE
void buffer_pop(uint8_t* buffer, size_t buf_size, size_t index)
{
    for (size_t i = index + 1; i < buf_size; i++)
        buffer[i - 1] = buffer[i];
}


typedef enum
{
    NoSequence = 0,
    SeqCursorLeft = 1,
    SeqCursorRight = 2,
    SeqCursorUp = 3,
    SeqCursorDown = 4,
    SeqColor256 = 5,
} Sequence;

typedef struct
{
    const char* start;
    char end;
} SequenceInfo;

SCL_STATIC_API_BEFORE_TYPE const
SequenceInfo sequences[] = {
    {0, 0},
    {"[", 'D'},
    {"[", 'C'},
    {"[", 'A'},
    {"[", 'B'},
    {"[38;5;", 'm'},
};

SCL_STATIC_API_BEFORE_TYPE
void write_sequence1_8(SCLConsoleBufferContext* ctx, Sequence seq, uint8_t arg)
{
    if (not seq)
        return;
    char buffer[16] = {"\e[000m"};
    char* it = buffer + 1;
    const char* start = sequences[seq].start;
    while (*start)
        *it++ = *start++;
    uint8_t len = (arg > 0 ? arg >= 10 ? arg >= 100 ? 3 : 2 : 1 : 0);
    it += len;
    char* ait = it;
    while (arg) {
        *--ait = arg % 10 + '0';
        arg /= 10;
    }
    *it++ = sequences[seq].end;
    ctx->write(ctx->opaque, buffer, it - buffer);
}

SCL_STATIC_API_BEFORE_TYPE
void safe_update(SCLConsoleBufferContext* ctx, const void* data, size_t size, SHLParseState prev_state, uint8_t off, const char* completes)
{
    coprintf("Safe write at '%s'",
             std::string((const char*)data, (const char*)data + size).c_str());
    ctx->write(ctx->opaque, "\e7", 2);
    const char* it = (const char*)data;
    for (size_t i = 0; i < size; i++) {
        if (ctx->colors) {
            prev_state = shl_parse_next(prev_state, *it).state;
            write_sequence1_8(ctx, SeqColor256, ctx->colors[shl_get_token(prev_state)]);
        }
        ctx->write(ctx->opaque, it++, 1);
    }
    if (ctx->colors) {
        write_sequence1_8(ctx, SeqColor256, 15);
    }
    ctx->write(ctx->opaque, "\e8", 2);
}

typedef struct
{
    const void* data;
    size_t size;
} UpdateRegion;

typedef struct
{
    Sequence seq;
    uint8_t arg;
} SequenceAfter;

#define UPDATE_BITMAP16 \
    ( (0 << NoAction) \
    | (0 << CursorUp) \
    | (0 << CursorDown) \
    | (0 << CursorRight) \
    | (0 << CursorLeft) \
    | (1 << DeleteBefore) \
    | (1 << DeleteAfter) \
    | (0 << Execute) \
    | (0 << Skip) \
    | (1 << Fallback) \
    | (1 << Insert) )

SCL_STATIC_API_BEFORE_TYPE
bool sclcb_on_char_next(SCLConsoleBufferContext* ctx, char ch)
{
    if (ctx->escape_index)
        ctx->buffer[ctx->size + ctx->escape_stack_size++] = ch;
    ARDRule rule = ard_find_rule(&escape_rules[ctx->escape_index], ch);
    ctx->escape_index = rule.id_after;
    uint16_t old_cur = ctx->cursor;
    SequenceAfter seq_after = {NoSequence, 0};
    uint8_t action = rule.value & 0xF;
    switch (action)
    {
    case NoAction:
        coprintf("NoAction\n");
        break;

    case Insert:
        coprintf("Insert %c(%d)\n", ch, ch);
        buffer_insert(ctx->buffer, ctx->size + 1, ctx->cursor, ch);
        seq_after.seq = SeqCursorRight;
        ctx->size++;
        ctx->cursor++;
        break;

    case Skip:
        coprintf("Skip\n");
        break;

    case Fallback: {
        const uint8_t* escape_stack = ctx->buffer + ctx->size;
        uint16_t old_cur = ctx->cursor;
        coprintf("Reached Fallback, flush escape stack: '%s'\n",
                 [&] { std::string s; for (int i = 0; i < ctx->escape_stack_size; i++) s += translate(escape_stack[i]); return s; }().c_str());
        for (uint8_t i = 0; i < ctx->escape_stack_size; i++) {
            uint8_t tch = translate(escape_stack[i]);
            buffer_insert(ctx->buffer, ctx->size, ctx->cursor, tch);
            ctx->size++;
            ctx->cursor++;
        }
        seq_after.seq = SeqCursorRight;
        seq_after.arg = ctx->size - old_cur;
        ctx->escape_stack_size = 0;
    }   break;

    case CursorUp:
        coprintf("CursorUp\n");
        break;

    case CursorDown:
        coprintf("CursorDown\n");
        break;

    case CursorRight:
        coprintf("CursorRight %d < %d\n",
                 ctx->cursor, ctx->size);
        if (ctx->cursor < ctx->size)
        {
            ctx->cursor++;
            seq_after.seq = SeqCursorRight;
        }
        break;

    case CursorLeft:
        coprintf("CursorLeft %d > 0\n",
                 ctx->cursor);
        if (ctx->cursor > 0)
        {
            ctx->cursor--;
            seq_after.seq = SeqCursorLeft;
        }
        break;

    case DeleteAfter:
        coprintf("DeleteAfter %d < %d\n",
                 ctx->cursor, ctx->size);
        if (ctx->cursor < ctx->size)
        {
            buffer_pop(ctx->buffer, sizeof(ctx->buffer), ctx->cursor);
            ctx->size--;
            ctx->buffer[ctx->size] = ' ';
        }
        break;

    case DeleteBefore:
        coprintf("DeleteBefore %d != 0\n",
                 ctx->cursor);
        if (ctx->cursor != 0)
        {
            ctx->cursor--;
            buffer_pop(ctx->buffer, ctx->size + 1, ctx->cursor);
            ctx->size--;
            ctx->buffer[ctx->size] = ' ';
            seq_after.seq = SeqCursorLeft;
        }
        break;

    case Execute:
        coprintf("Execute '%s'\n",
                 std::string((char*)ctx->buffer, (char*)ctx->buffer + ctx->size).c_str());
        ctx->write(ctx->opaque, "\r\n", 2);
        ctx->buffer[ctx->size] = '\0';
        ctx->execute(ctx->opaque, &ctx->buffer[0], ctx->size);
        memset(ctx->buffer, 0, ctx->buffer_size);
        ctx->size = 0;
        ctx->cursor = 0;
        break;

    default:
        coprintf("Unknown instruction '%d'\n",
                 rule.value);
        break;
    }
    if (UPDATE_BITMAP16 & (1 << action)) {
        SHLParseState state = 0;
        uint8_t* start = ctx->buffer + old_cur;
        if (ctx->colors) {
            for (const uint8_t* it = ctx->buffer; it < start; it++)
                state = shl_parse_next(state, *it).state;
        }
        char completes[32] = {"Tab1\nTab2\nTab3"};
        safe_update(ctx, start, (ctx->size > old_cur ? ctx->size - old_cur : 1), state, ctx->cursor, completes);
    }
    write_sequence1_8(ctx, seq_after.seq, seq_after.arg);
    return !(rule.value & SCLCB_PRIVATE_Return);
}

SCL_CPP_ANON_NAMESPACE_END


SCL_EXPORT_API_BEFORE_TYPE
SCLConsoleBufferContext SCL_EXPORT_API_AFTER_TYPE sclcb_make_context(void* buffer, uint16_t size,
                                                                     void* opaque,
                                                                     void (*write)(void*, const void*, size_t),
                                                                     void (*execute)(void*, void*, size_t),
                                                                     const uint8_t* colors)
{
    SCLConsoleBufferContext ctx;
    ctx.buffer = (uint8_t*)buffer;
    ctx.buffer_size = size;
    ctx.size = ctx.cursor = 0;
    ctx.escape_stack_size = 0;
    ctx.opaque = opaque;
    ctx.write = write;
    ctx.execute = execute;
    ctx.colors = colors;
    return ctx;
}

SCL_EXPORT_API_BEFORE_TYPE
void SCL_EXPORT_API_AFTER_TYPE sclcb_on_char(SCLConsoleBufferContext* ctx, char ch)
{
    while (sclcb_on_char_next(ctx, ch));
}

SCL_EXPORT_API_BEFORE_TYPE
void SCL_EXPORT_API_AFTER_TYPE sclcb_clear(SCLConsoleBufferContext* ctx)
{
    ctx->size = ctx->cursor = 0;
}
