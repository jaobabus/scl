#include <scl/parse.h>
#include <scl/error.h>
#include <scl/ard.h>

#include <stdio.h>
#include <scl/calt.h>

#define TRACE_VIA_PRINTF(a...)
//#define TRACE_VIA_PRINTF(a...) a


SCL_CPP_ANON_NAMESPACE_START

// -- ARD-Table 'ParseRules' --
// THIS BLOCK AUTOGENERATED
// Do NOT change it
// {

/* Rules mapping
 * 
 * Token:
 *   [escape: bit[2]] [token: bit[4]] [state: bit[2]]
 *
 * Key:
 *   [char: bit[7]]
 *
 * Value:
 *   [data: bit[2]] [ret: bit] [0: bit] [0: bit] [0: bit[3]]
 *   [data: bit[2]] [ret: bit] [0: bit] [1: bit] [0: bit] [state: bit[2]]
 *   [data: bit[2]] [ret: bit] [1: bit] [token: bit[4]]
 *
 */
#define SCL_PRIVATE_DataAction(a) ((a) << 6)
#define SCL_PRIVATE_NoStore SCL_PRIVATE_DataAction(0)
#define SCL_PRIVATE_Store8  SCL_PRIVATE_DataAction(1)
#define SCL_PRIVATE_Store3  SCL_PRIVATE_DataAction(2)
#define SCL_PRIVATE_Store4  SCL_PRIVATE_DataAction(3)
#define SCL_PRIVATE_Return  0x20
#define SCL_PRIVATE_Token(token) (0x10 | (token))
#define SCL_PRIVATE_State(state, switch) (0x08 | (state) | ((switch) ? 0x4 : 0x0))

SCL_STATIC_API_BEFORE_TYPE
const ARDMiniRule token_id_map[] = {
    {(0x40 | SHLT_None << 2) | 0, 0x00},
    {(0x40 | SHLT_Eof << 2) | 0, 0x0C},
    {(0x40 | SHLT_StateError << 2) | 0, 0x55},
    {(0x40 | SHLT_Whitespace << 2) | 0, 0x06},
    {(0x40 | SHLT_FlagEqual << 2) | 0, 0x23},
    {(0x40 | SHLT_Flag << 2) | 0, 0x1B},
    {(0x40 | SHLT_Flag << 2) | 3, 0x1F},
    {(0x40 | SHLT_Variable << 2) | 0, 0x25},
    {(0x40 | SHLT_Variable << 2) | 3, 0x27},
    {(0x40 | SHLT_String << 2) | 0, 0x29},
    {(0x40 | SHLT_String << 2) | 1, 0x2D},
    {(0x40 | SHLT_String << 2) | 2, 0x33},
    {(0x40 | SHLT_String << 2) | 3, 0x39},
    {(0x40 | SHLT_Word << 2) | 0, 0x0F},
    {(0x40 | SHLT_Word << 2) | 1, 0x19},
    {(0x40 | SHLT_EscapeStart << 2) | 0, 0x3B},
    {(0x40 | SHLT_EscapeHex << 2) | 0, 0x51},
    {(0x40 | SHLT_EscapeHex2 << 2) | 0, 0x53},
    {0, 0x55}
};

SCL_STATIC_API_BEFORE_TYPE
uint8_t get_id_by_token_state(uint8_t state)
{
    if (state & 0xC0)
        state = (SHLT_EscapeStart - 1 + (state >> 6)) << 2;
    return ard_find_rule((const uint8_t*)token_id_map, 0x40 | state).value;
}

SCL_STATIC_API_BEFORE_TYPE
uint8_t get_id_by_token(uint8_t token, uint8_t state)
{
    return get_id_by_token_state((token << 2) | state);
}

SCL_STATIC_API_BEFORE_TYPE
const char* dbg_name_of_rulemap(uint8_t id)
{
    static char buf[1024];
    switch(id) {
    case 0x00: return "SHLT_None[0]";
    case 0x06: return "SHLT_Whitespace[0]";
    case 0x0C: return "SHLT_Eof[0]";
    case 0x0F: return "SHLT_Word[0]";
    case 0x19: return "SHLT_Word[1]";
    case 0x1B: return "SHLT_Flag[0]";
    case 0x1F: return "SHLT_Flag[3]";
    case 0x23: return "SHLT_FlagEqual[0]";
    case 0x25: return "SHLT_Variable[0]";
    case 0x27: return "SHLT_Variable[3]";
    case 0x29: return "SHLT_String[0]";
    case 0x2D: return "SHLT_String[1]";
    case 0x33: return "SHLT_String[2]";
    case 0x39: return "SHLT_String[3]";
    case 0x3B: return "SHLT_EscapeStart[0]";
    case 0x51: return "SHLT_EscapeHex[0]";
    case 0x53: return "SHLT_EscapeHex2[0]";
    case 0x55: return "SHLT_StateError[0]";
    default: sprintf(buf, "Unknown 0x%02hhX", id); return buf;
    }
}


SCL_STATIC_API_BEFORE_TYPE
const uint8_t rules[] = {
/* 00 */ // Token.NotInited[0]
  /* 00 */ '$',
  /* -- */ SCL_PRIVATE_NoStore | SCL_PRIVATE_Token(SHLT_Variable),
  /* 02 */ '-',
  /* -- */ SCL_PRIVATE_NoStore | SCL_PRIVATE_Token(SHLT_Flag),
  /* 04 */ 0x00,
  /* -- */ SCL_PRIVATE_NoStore | SCL_PRIVATE_Token(SHLT_Word),
/* 06 */ // Token.Whitespace[0]
  /* 06 */ ' ',
  /* -- */ SCL_PRIVATE_Store8 | SCL_PRIVATE_Return,
  /* 08 */ '\t',
  /* -- */ SCL_PRIVATE_Store8 | SCL_PRIVATE_Return,
  /* 0A */ 0x00,
  /* -- */ SCL_PRIVATE_NoStore | SCL_PRIVATE_Token(SHLT_None),
/* 0C */ // Token.Eof[0]
  /* 0C */ 0x00 | ARD_HIA,
  /* -- */ SCL_PRIVATE_NoStore | SCL_PRIVATE_Token(SHLT_Eof) | SCL_PRIVATE_Return,
  /* -- */ 0x00, // const
/* 0F */ // Token.Word[0]
  /* 0F */ '\"',
  /* -- */ SCL_PRIVATE_NoStore | SCL_PRIVATE_Token(SHLT_String),
  /* 11 */ '\'',
  /* -- */ SCL_PRIVATE_NoStore | SCL_PRIVATE_Token(SHLT_String),
  /* 13 */ ' ',
  /* -- */ SCL_PRIVATE_NoStore | SCL_PRIVATE_Token(SHLT_Whitespace),
  /* 15 */ '\\',
  /* -- */ SCL_PRIVATE_NoStore | SCL_PRIVATE_State(1, false) | SCL_PRIVATE_Return,
  /* 17 */ 0x00,
  /* -- */ SCL_PRIVATE_Store8 | SCL_PRIVATE_Return,
/* 19 */ // Token.Word[1]
  /* 19 */ 0x00,
  /* -- */ SCL_PRIVATE_Store8 | SCL_PRIVATE_State(0, false) | SCL_PRIVATE_Return,
/* 1B */ // Token.Flag[0]
  /* 1B */ '-',
  /* -- */ SCL_PRIVATE_NoStore | SCL_PRIVATE_State(3, false) | SCL_PRIVATE_Return,
  /* 1D */ 0x00,
  /* -- */ SCL_PRIVATE_NoStore | SCL_PRIVATE_State(3, false) | SCL_PRIVATE_Return,
/* 1F */ // Token.Flag[3]
  /* 1F */ '=',
  /* -- */ SCL_PRIVATE_Store8 | SCL_PRIVATE_Token(SHLT_FlagEqual) | SCL_PRIVATE_Return,
  /* 21 */ 0x00,
  /* -- */ SCL_PRIVATE_Store8 | SCL_PRIVATE_Return,
/* 23 */ // Token.FlagEqual[0]
  /* 23 */ 0x00,
  /* -- */ SCL_PRIVATE_NoStore | SCL_PRIVATE_Token(SHLT_None),
/* 25 */ // Token.Variable[0]
  /* 25 */ 0x00,
  /* -- */ SCL_PRIVATE_NoStore | SCL_PRIVATE_State(3, false) | SCL_PRIVATE_Return,
/* 27 */ // Token.Variable[3]
  /* 27 */ 0x00,
  /* -- */ SCL_PRIVATE_Store8 | SCL_PRIVATE_Return,
/* 29 */ // Token.String[0]
  /* 29 */ '\"',
  /* -- */ SCL_PRIVATE_NoStore | SCL_PRIVATE_State(1, false) | SCL_PRIVATE_Return,
  /* 2B */ '\'',
  /* -- */ SCL_PRIVATE_NoStore | SCL_PRIVATE_State(2, false) | SCL_PRIVATE_Return,
/* 2D */ // Token.String[1]
  /* 2D */ '\\',
  /* -- */ SCL_PRIVATE_NoStore | SCL_PRIVATE_Token(SHLT_EscapeStart) | SCL_PRIVATE_Return,
  /* 2F */ '\"',
  /* -- */ SCL_PRIVATE_NoStore | SCL_PRIVATE_State(3, false) | SCL_PRIVATE_Return,
  /* 31 */ 0x00,
  /* -- */ SCL_PRIVATE_Store8 | SCL_PRIVATE_Return,
/* 33 */ // Token.String[2]
  /* 33 */ '\\',
  /* -- */ SCL_PRIVATE_NoStore | SCL_PRIVATE_Token(SHLT_EscapeStart) | SCL_PRIVATE_Return,
  /* 35 */ '\'',
  /* -- */ SCL_PRIVATE_NoStore | SCL_PRIVATE_State(3, false) | SCL_PRIVATE_Return,
  /* 37 */ 0x00,
  /* -- */ SCL_PRIVATE_Store8 | SCL_PRIVATE_Return,
/* 39 */ // Token.String[3]
  /* 39 */ 0x00,
  /* -- */ SCL_PRIVATE_NoStore | SCL_PRIVATE_Token(SHLT_None),
/* 3B */ // Escape.Start[0]
  /* 3B */ 'x',
  /* -- */ SCL_PRIVATE_NoStore | SCL_PRIVATE_Token(SHLT_EscapeHex),
  /* 3D */ 'r' | ARD_HIA,
  /* -- */ SCL_PRIVATE_NoStore | SCL_PRIVATE_Return,
  /* -- */ '\r', // const
  /* 40 */ 'b' | ARD_HIA,
  /* -- */ SCL_PRIVATE_NoStore | SCL_PRIVATE_Return,
  /* -- */ '\b', // const
  /* 43 */ 'e' | ARD_HIA,
  /* -- */ SCL_PRIVATE_NoStore | SCL_PRIVATE_Return,
  /* -- */ '\033', // const
  /* 46 */ 'a' | ARD_HIA,
  /* -- */ SCL_PRIVATE_NoStore | SCL_PRIVATE_Return,
  /* -- */ '\a', // const
  /* 49 */ 'v' | ARD_HIA,
  /* -- */ SCL_PRIVATE_NoStore | SCL_PRIVATE_Return,
  /* -- */ '\v', // const
  /* 4C */ 'n' | ARD_HIA,
  /* -- */ SCL_PRIVATE_NoStore | SCL_PRIVATE_Return,
  /* -- */ '\n', // const
  /* 4F */ 0x00,
  /* -- */ SCL_PRIVATE_Store8 | SCL_PRIVATE_Return,
/* 51 */ // Escape.Hex[0]
  /* 51 */ 0x00,
  /* -- */ SCL_PRIVATE_Store4 | SCL_PRIVATE_Token(SHLT_EscapeHex2),
/* 53 */ // Escape.Hex2[0]
  /* 53 */ 0x00,
  /* -- */ SCL_PRIVATE_Store4 | SCL_PRIVATE_Return,
/* 55 */ // Token.StateError[0]
  /* 55 */ 0x00 | ARD_HIA,
  /* -- */ SCL_PRIVATE_NoStore | SCL_PRIVATE_Return,
  /* -- */ 0x01, // const
};

// }
// -- ARD-Table --


SCL_STATIC_API_BEFORE_TYPE
const char* parse_value(uint8_t s)
{
    static char buffer[1024];
    size_t size = 0;
    uint8_t d = s & 0xC0;
    size += snprintf(buffer + size, 1024 - size, "%s",
                    &"NoStore\0Store8\0\0Store3\0\0Store4\0"[(d >> 6) * 8]);
    if (s & SCL_PRIVATE_Return)
        size += sprintf(buffer + size, ", Return");
    if (s & SCL_PRIVATE_Token(0))
        size += sprintf(buffer + size, ", token=%s",
                        shl_str_token(shl_get_token(s << 2)));
    else if (s & SCL_PRIVATE_State(0, 0)) {
        size += sprintf(buffer + size, ", state=%d",
                        s & 0x3);
        if (s & 0x40)
        size += sprintf(buffer + size, ", switch");
    }
    return buffer;
}

SCL_STATIC_API_BEFORE_TYPE
const char* parse_state(uint8_t s)
{
    static char buffer[1024];
    size_t size = 0;
    size += snprintf(buffer + size, 1024 - size, "%s",
                    &"NoEscape\0\0StartEsc\0\0HexEscape\0OctEscape\0"[(s >> 6) * 10]);
    size += sprintf(buffer + size, ", token=%s",
                    shl_str_token(shl_get_token(s)));
    size += sprintf(buffer + size, ", state=%d",
                    s & 0x3);
    return buffer;
}

SCL_STATIC_API_BEFORE_TYPE
uint8_t parse_next(SHLParseResult* res, uint8_t key)
{
    TRACE_VIA_PRINTF(printf("parse_next(%s, '%c'(%d))\n", parse_state(res->state), key, key);)
    if (key == 0) {
        res->state = SHLT_Eof << 2;
        return true;
    }
    if ((res->state & 0x3) == 3 and
            (shl_get_token(res->state) == SHLT_Flag or shl_get_token(res->state) == SHLT_Variable))
    {
        if (!(key >= 'A' and key <= 'Z' or key >= '0' and key <= '9' or key >= 'a' and key <= 'z' or key == '_' or key == '='))
            res->state = SHLT_None << 2;
    }
    uint8_t off = get_id_by_token_state(res->state);
    ARDRule rule = ard_find_rule((const uint8_t*)rules + off, key);
    TRACE_VIA_PRINTF(printf("%s['%c'(%d)] = *0x%02hhX = (%s, put=%d)\n",
                            dbg_name_of_rulemap(off), key, key, off, parse_value(rule.value), rule.id_after);)

    if (res->state & 0xC0)
    {
        if (rule.value & SCL_PRIVATE_Return) {
            TRACE_VIA_PRINTF(printf("End escape\n");)
            res->state = res->state & 0x3F;
        }
        rule.value |= SCL_PRIVATE_Return;
    }
    if (rule.value & SCL_PRIVATE_Token(0))
    {
        uint8_t token = (rule.value & 0xF);
        if (token < SHLT_EscapeStart) {
            TRACE_VIA_PRINTF(printf("token(%s -> %s)\n", shl_str_token(shl_get_token(res->state)), shl_str_token(shl_get_token(rule.value << 2)));)
            res->state = (token << 2);
        }
        else {
            TRACE_VIA_PRINTF(printf("escape=%s\n", shl_str_token(shl_get_token(rule.value << 2)));)
            res->state = res->state & 0x3F | ((token - SHLT_EscapeStart + 1) << 6);
        }
    }
    else if (rule.value & SCL_PRIVATE_State(0, 0))
    {
        TRACE_VIA_PRINTF(printf("state(%d -> %d)\n", res->state & 3, rule.value & 3);)
        res->state = res->state & ~0x3 | rule.value & 0x3;
    }

    uint8_t action = rule.value >> 6;
    switch (action)
    {
    case SCL_PRIVATE_NoStore >> 6:
        break;
    case SCL_PRIVATE_Store8 >> 6:
        res->parsed = key;
        break;
    case SCL_PRIVATE_Store3 >> 6:
        res->parsed = key - '0';
        break;
    case SCL_PRIVATE_Store4 >> 6:
        res->parsed = key - '0';
        break;
    }
    return (rule.value & SCL_PRIVATE_Return);
}


SCL_CPP_ANON_NAMESPACE_END


SCL_EXPORT_API_BEFORE_TYPE
SHLToken SCL_EXPORT_API_AFTER_TYPE shl_get_token(SHLParseState state)
{
    return (SHLToken)((state >> 2) & 0xF);
}

SCL_EXPORT_API_BEFORE_TYPE
SHLParseResult SCL_EXPORT_API_AFTER_TYPE shl_parse_next(SHLParseState prev_state, char next)
{
    SHLParseResult result = {prev_state};
    while (!parse_next(&result, next));
    return result;
}
